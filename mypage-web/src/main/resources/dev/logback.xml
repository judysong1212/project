<?xml version="1.0" encoding="UTF-8"?>

<!-- 30초마다 설정 파일의 변경을 확인한다. 파일이 변경되면 다시 로딩한다 <configuration debug="true"> -->
<configuration scan="true" scanPeriod="30 seconds">
     <contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator">
       <resetJUL>true</resetJUL>
     </contextListener>
          <!-- 외부 설정파일을 사용할 수 있다. -->
    <property resource="logbackres.properties"/>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- rollover daily -->
            <fileNamePattern>logs/logFile.%d{yyyy-MM-dd HH.mm.ss}.%i.log.zip</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy
                    class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <!-- or whenever the file size reaches 100MB -->
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
             <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <Pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</Pattern>
        </encoder>
    </appender>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</Pattern>
        </layout>
          <!-- myBatis 에서 주석에 'NOT_SQL_LOG'를 넣고 로그에서는 제외한다.
            <filter class="ch.qos.logback.core.filter.EvaluatorFilter">
                <evaluator>
                    <expression>return message.contains("NOT_SQL_LOG");</expression>
                </evaluator>
                <OnMismatch>NEUTRAL</OnMismatch>
                <OnMatch>DENY</OnMatch>
            </filter> -->
    </appender>
    <!-- 3rdparty Loggers -->
    <logger name="org.springframework.aop.framework.Cglib2AopProxy" level="error" additivity="false"> 
      <appender-ref ref="STDOUT" />
      </logger>
    <logger name="org.springframework.core">
               <level value="error" />
                 <appender-ref ref="STDOUT" />
    </logger>
    
    <logger name="org.springframework" level="debug" additivity="false">
		<appender-ref ref="STDOUT" />
		  <appender-ref ref="FILE"/>
	</logger>
    
       <logger name="org.springframework.beans">
              <level value="error" />
                <appender-ref ref="STDOUT" />
       </logger>
       <logger name="org.springframework.context">
              <level value="error" />
                <appender-ref ref="STDOUT" />
       </logger>
       <logger name="org.springframework.web">
              <level value="error" />
                <appender-ref ref="STDOUT" />
       </logger>
       
        <!-- 관련 정보 http://magefister.egloos.com/2053938 -->
       <logger name="java.sql">
         <level value="debug"/>
         <appender-ref ref="STDOUT" />
         <appender-ref ref="FILE"/>
       </logger>
       <!-- SQL문만을 로그로 남기며, PreparedStatement일 경우 관련된 argument 값으로 대체된 SQL문이 보여진다. -->
       <logger name="jdbc.sqlonly" additivity="false">
           <level value="error"/>
           <appender-ref ref="STDOUT" />
       </logger>
       <!-- SQL문과 해당 SQL을 실행시키는데 수행된 시간 정보(milliseconds)를 포함한다. -->
       <logger name="jdbc.sqltiming">
           <level value="debug"/>
           <appender-ref ref="STDOUT" />
       </logger>
       <!-- ResultSet을 제외한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그가 생성되므로 특별히 JDBC 문제를 추적해야 할 필요가 있는 경우를 제외하고는 사용을 권장하지 않는다. -->
       <logger name="jdbc.audit">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>
       <!-- ResultSet을 포함한 모든 JDBC 호출 정보를 로그로 남기므로 매우 방대한 양의 로그가 생성된다. -->
       <logger name="jdbc.resultset">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>

       <logger name="jdbc.connection">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>
       
       <logger name="o.a.c.b.converters.StringConverter">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>
       <logger name="o.a.c.b.converters.ArrayConverter">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>
       
      <logger name="org.apache.commons.digester.Digester">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>
       
         <logger name="o.a.commons.beanutils.ConvertUtils">
       <appender-ref ref="STDOUT" />
           <level value="error"/>
       </logger>
 <!--
      
       <logger name="java.sql.connection" level="info" additivity="false">
            <appender-ref ref="STDOUT" />
   </logger>
-->
     <logger name="org.apache.catalina.session.ManagerBase">
       <appender-ref ref="STDOUT" />
           <level value="info"/>
       </logger>  
    
     <logger name="org.apache.tomcat.util.http.Cookies">
       <appender-ref ref="STDOUT" />
           <level value="info"/>
       </logger>      
    
    <if condition='property("RUN_MODE").equals("SERVICE")'>
        <then>
            <!-- 설정파일에 RUN_MODE 가 SERVICE로 정의되어 있으면 로깅 레벨을 INFO로 지정 -->
            <root level="ERROR">
                <appender-ref ref="STDOUT"/>
                <appender-ref ref="FILE"/>
            </root>
        </then>
        <!-- 설정파일에 RUN_MODE 가 SERVICE로 정의되어 있지 않으면  로깅 레벨을 DEBUG 지정 -->
        <else>
            <root level="debug">
                <appender-ref ref="STDOUT"/>
                <appender-ref ref="FILE"/>
            </root>
        </else>
    </if>
</configuration> 